import random
import math

A=[]
B=[]

# #先隨機抽一個N N落在[1,100000]內，令N1=100000
# #A的長度在100000以內

# #A的每個元素會落在[0,10000]內，令N2=10000

# # ====================================================================
# # 想辦法生出一個長度隨機<N1，元素值隨機但必<N2 的A向量
# # ====================================================================

# N1=8 #100000
# N2=5 #10000

# print("長度N1=",N1,"，元素值上限N2=",N2)
# print("\n")

# #不知道怎麼宣告一個空的int變數，先令他=0
# fn=0
# k=0

# #令一個矩陣，while下雙條件且
# while k<N1:
#     #N3必定<N2
#     N3=random.sample(range(1,N2),1)
#     N3=int(N3[0])
    
#     print("第",k+1,"個元素=向量位置k=",k,"，第k個位置的值=N3=",N3)

#     A.append(N3)
    
#     fn += 2**A[k]
#     k += 1
    
# print("A向量=",A)
# print("binarianA= fn=",fn)



# ====================================================================
# 接下來要用fn來回推B
# ====================================================================

# 令一個固定的A向量作為測試對象
A = [1,0,2,0,0,2]
print(A)

# 計算出該 A向量 的fn是多少
n = len(A)
fn = 0
sum=0

while sum<n:
    fn += 2**A[sum]
    sum += 1

print("A向量=",A,"，A向量長度=",n,"；對應的fn=",fn)
print("\n")


bn=0
sumb=0
while bn<fn:

    #對fn取log2，取完的值取整，放入B[0]
    
    print("fn =",fn)

    B.append( int(math.log(fn,2)) )   #先把取log2後取整的值放入B[0]
    
    bn += 2**B[sumb]                  #再順手計算 bn,此時sumb=0
    sumb += 1                         #計數+1

    print("B[0] =",B[0])
    print("\n")


    #對fn-2**B[0]再取log2，一樣取完的值取整，放入B[1]
    print("fn-2**B[0] =",fn-2**B[0])

    B.append( int(math.log(fn-2**B[0],2)) )
    print("B[1] =",B[1])
    print("\n")


    #對fn-2**B[1]-2**B[0]再取log2…重複以上循環
    print("fn-2**B[1]-2**B[0] =",fn-2**B[1]-2**B[0])

    B.append( int(math.log(fn-2**B[1]-2**B[0],2)) )
    print("B[2] =",B[2])
    print("\n")


    #直到 fn-sum(2**B[i])=0，此循環停止


    # 計算此時 B向量 的fn是多少
    n_b = len(B)
    fn_b = 0
    sum_b=0

    while sum_b<n_b:
        fn_b += 2**B[sum_b
        sum_b += 1



'''把生成的B，其長度len(B)存進整數值b，並將向量B存成B
'''


'''遞迴做這件事，每次做，都拿len(B)都跟前一次的b做比較
   如果新的比較小
   就把小的再令給b，並且把新的B向量替換掉舊的B向量

   遞迴N1次
'''



'''
g=type(A[1])
print(g)

B=random.sample(A,len(A)-2)
print(B)


#前面產生了浮點數所以fn變成了浮點數XD
fn=2**A[0]+2**A[1]+2**A[2]+2**A[3]+2**A[4]+2**A[5]
print(fn)

'''
