import random
import math

A=[]
B=[]

# # A 的長度隨機，落在 [1,100000] 內，令N1=100000
# # A 的每個元素，落在 [0,10000]  內，令M1=10000

# # ====================================================================
# # 想辦法生出一個長度隨機<N1，元素值隨機但必<N2 的A向量
# # ====================================================================

# 上限值
N1=10 #100000
K1=3 #10000

N1=random.sample(range(1,N1),1) # 隨機決定向量長度N1，取出來的東西為字串
N1=int(N1[0])

print("\n")
print("長度上限= N1=",N1,"，元素值上限= K1=",K1)
print("\n")

#不知道怎麼宣告一個空的int變數，先令他=0
fn=0
k=0

while k<N1:
    #M2必定<M1
    K2=random.sample(range(0,K1),1) #隨機決定K2的值
    K2=int(K2[0])
    
    print("第",k+1,"個元素= 向量位置k=",k,"，第k個位置的值= K2=",K2)

    A.append(K2)
    
    fn += 2**A[k]
    k += 1
    
print("A向量=",A)
print("binarianA= fn=",fn)
print("\n")




# ====================================================================
# 令一個固定的A向量、fn，作為測試對象
# ====================================================================
# A = [1,0,2,0,0,2]

# # 計算出該 A向量 的fn是多少
# n = len(A)
# fn = 0
# sum=0

# while sum<n:
#     fn += 2**A[sum]
#     sum += 1

# print("A向量=",A,"，A向量長度=",n,"；對應的fn=",fn)
# print("\n")



# ====================================================================
# 接下來要用fn來回推B
# ====================================================================

fnb=0
sumb=0
fna=fn

while fna != 0:

    #對fn取log2，取完的值取整，放入B[0]
    
    print("fn= fna=",fna)

    B.append( int(math.log(fna,2)) ) # 先把取log2後取整的值放入B[0]
    print("sumb=",sumb)
    print("B[0]=",B[0])
    print("B[sumb]=",B[sumb])
    print("\n")

    fnb +=  2**B[sumb]               # 再順手計算 bn,此時 sumb=0
    fna += -2**B[sumb]               # fna 扣掉 2**B[0]，剩下來的成為新的fna
    sumb += 1                        # 計數+1,雖不是用sumb來限制迴圈次數，但要用他來安排向量填入的順序



print("B向量 =",B,"fnb =",fnb)
print("\n")

