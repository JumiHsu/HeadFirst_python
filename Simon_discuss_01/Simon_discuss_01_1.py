


import random

A=[]
B=[]



#先隨機抽一個N N落在[1,100000]內，令N1=100000
#A的長度在100000以內

#A的每個元素會落在[0,10000]內，令N2=10000


'''想辦法生出一個長度隨機<N1，元素值隨機但必<N2 的A向量
'''

N1=20
N2=10

print("長度N1=",N1,"，元素值上限N2=",N2)
print("\n")

#不知道怎麼宣告一個空的int變數，先令他=0
fn=0
k=0

#令一個矩陣，while下雙條件且
while k<N1:
    #N3必定<N2
    N3=random.sample(range(1,N2),1)
    N3=int(N3[0])
    
    print("第",k+1,"個元素=向量位置k=",k,"，第k個位置的值=N3=",N3)

    A.append(N3)

    #這邊只是驗算
    #A=[1,0,2,0,0,2]
    #N1=6

    #print("A[0]=N3",A[0])    
    #print("k=",k,"N3=",N3)    
    #print("A[k]=",A[k])
    
    fn+=2**A[k]
    k+=1
    

print(A)
print("binarianA=fn=",fn)

'''接下來要用fn來回推B
'''
#對fn取log2，取完的值取整，放入B[0]




#對fn-2**B[0]再取log2，一樣取完的值取整，放入B[1]

#對fn-2**B[1]-2**B[0]再取log2…重複以上循環

#直到 fn-sum(2**B[i])=0，此循環停止


'''把生成的B，其長度len(B)存進整數值b，並將向量B存成B
'''


'''遞迴做這件事，每次做，都拿len(B)都跟前一次的b做比較
   如果新的比較小
   就把小的再令給b，並且把新的B向量替換掉舊的B向量

   遞迴N1次
'''



'''
g=type(A[1])
print(g)

B=random.sample(A,len(A)-2)
print(B)


#前面產生了浮點數所以fn變成了浮點數XD
fn=2**A[0]+2**A[1]+2**A[2]+2**A[3]+2**A[4]+2**A[5]
print(fn)

'''
